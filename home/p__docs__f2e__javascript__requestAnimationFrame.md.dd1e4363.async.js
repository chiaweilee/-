(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[30],{jBMl:function(e,a,n){"use strict";n.r(a);var t=n("q1tI"),r=n.n(t),o=n("i8i4"),c=n.n(o),i=n("uzov");a["default"]=function(e){return r.a.useEffect(()=>{const e=document.querySelectorAll("pre[data-react-lang]");for(let a=0;a<e.length;a++){const n=e[a],t=n.getAttribute("data-react-lang"),r=n.getAttribute("data-react-children"),o=document.createElement("div");o["data-react-mounted"]="",n.parentNode.insertBefore(o,n),n.remove(),c.a.render(Object(i["a"])(t,r),o)}return()=>{const e=document.querySelectorAll("div[data-react-mounted]");for(let a=0;a<e.length;a++){const n=e[a];c.a.unmountComponentAtNode(n)}}},[]),r.a.createElement("section",{dangerouslySetInnerHTML:{__html:'<html><head></head><body><h2 id="requestanimationframe"><a class="anchor" href="#requestanimationframe"></a>requestAnimationFrame</h2>\n<p>usually <code>60 times per second</code>, but generally match the display refresh rate as per W3C recommendation.</p>\n<p>callback is passed a single argument, a DOMHighResTimeSteamp, indicates the current time then callbacks queued by <code>requestAnimationFrame()</code> begin to fire.</p>\n<pre><code class="language-js">window.requestAnimationFrame(function (timestamp) {})\n</code></pre>\n<h3 id="cancelanimationframe"><a class="anchor" href="#cancelanimationframe"></a>cancelAnimationFrame</h3>\n<pre><code class="language-js">const a = window.requestAnimationFrame(...)\nwindow.cancleAnimationFrame(a)\n</code></pre>\n</body></html>'}})}}}]);