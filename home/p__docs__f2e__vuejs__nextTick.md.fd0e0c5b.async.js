(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[39],{"41Tp":function(e,t,n){"use strict";n.r(t);var a=n("q1tI"),o=n.n(a),d=n("i8i4"),r=n.n(d),c=n("uzov");t["default"]=function(e){return o.a.useEffect(()=>{const e=document.querySelectorAll("pre[data-react-lang]");for(let t=0;t<e.length;t++){const n=e[t],a=n.getAttribute("data-react-lang"),o=n.getAttribute("data-react-children"),d=document.createElement("div");d["data-react-mounted"]="",n.parentNode.insertBefore(d,n),n.remove(),r.a.render(Object(c["a"])(a,o),d)}return()=>{const e=document.querySelectorAll("div[data-react-mounted]");for(let t=0;t<e.length;t++){const n=e[t];r.a.unmountComponentAtNode(n)}}},[]),o.a.createElement("section",{dangerouslySetInnerHTML:{__html:'<html><head></head><body><h2 id="nexttick"><a class="anchor" href="#nexttick"></a>nextTick</h2>\n<p><code>callback</code> to be executed after the next DOM update cycle.<br />\nUse it immediately after you\u2019ve changed some data to wait for the DOM update.</p>\n<h3 id="dom-update-asynchronously"><a class="anchor" href="#dom-update-asynchronously"></a>DOM update asynchronously</h3>\n<p>DOM is updated <code>asynchronously</code>.<br />\nWhen a value changed in Vue, the change is not immediately rendered to DOM.<br />\nInstead, Vue queues a DOM update and then, on a timer, updated the DOM.</p>\n</body></html>'}})}}}]);